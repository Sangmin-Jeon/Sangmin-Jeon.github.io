---
layout: post
title: BOJ_13164번_행복유치원
color: rgb(50, 170, 250)
feature-img: "assets/img/algoritms-img/algorithm_title_image.png"
thumbnail: "assets/img/algoritms-img/algorithm_title_image.png"
tags: [BOJ, 그리디, 정렬]
---

# [BOJ] 13164번 행복유치원 (Swift)
자료구조 && 알고리즘 문제 풀이 및 설명



![13164_result](https://github.com/Sangmin-Jeon/Sangmin-Jeon.github.io/assets/59474775/367f56e1-631d-4afe-9046-b9321a508f52)

||| 
|--| -- |
| 제목 | [BOJ] 13164번 행복유치원 |
| 출처 | [13164번 행복유치원](https://www.acmicpc.net/problem/13164) |
| 문제 제공| Baekjoon |
| 정답 비율 | 55.187% |
| 난이도 | [Solved.ac] 골드5 |
| 분류 | 그리디, 정렬 |

## 문제

행복 유치원 원장인 태양이는 어느 날 N명의 원생들을 키 순서대로 일렬로 줄 세우고, 총 K개의 조로 나누려고 한다. 각 조에는 원생이 적어도 한 명 있어야 하며, 같은 조에 속한 원생들은 서로 인접해 있어야 한다. 조별로 인원수가 같을 필요는 없다.

이렇게 나뉘어진 조들은 각자 단체 티셔츠를 맞추려고 한다. 조마다 티셔츠를 맞추는 비용은 조에서 가장 키가 큰 원생과 가장 키가 작은 원생의 키 차이만큼 든다. 최대한 비용을 아끼고 싶어 하는 태양이는 K개의 조에 대해 티셔츠 만드는 비용의 합을 최소로 하고 싶어한다. 태양이를 도와 최소의 비용을 구하자.

### 입력

입력의 첫 줄에는 유치원에 있는 원생의 수를 나타내는 자연수 N(1 ≤ N ≤ 300,000)과 나누려고 하는 조의 개수를 나타내는 자연수 K(1 ≤ K ≤ N)가 공백으로 구분되어 주어진다. 다음 줄에는 원생들의 키를 나타내는 N개의 자연수가 공백으로 구분되어 줄 서 있는 순서대로 주어진다. 태양이는 원생들을 키 순서대로 줄 세웠으므로, 왼쪽에 있는 원생이 오른쪽에 있는 원생보다 크지 않다. 원생의 키는 109를 넘지 않는 자연수이다.

### 출력

티셔츠 만드는 비용이 최소가 되도록 K개의 조로 나누었을 때, 티셔츠 만드는 비용을 출력한다.

## 전체 코드

### [Swift]

```swift
import Foundation

// MARK 입력
let input = readLine()!.split(separator: " ").compactMap({ Int($0) })
let n = input[0]
let k = input[1]
var children = readLine()!.split(separator: " ").compactMap({ Int($0) })

var gapList = [Int]()
for i in 0 ..< (children.count - 1) {
    gapList.append(children[i + 1] - children[i])
}
gapList.sort(by: <)
let answer = gapList[0 ..< n-k].reduce(0, +)
print(answer) // 정답 출력

// 입 출력 예 )
- 예제 입력 
	- n: 5  (배열 전체 크기)
	- k: 3 (그룹 수)
	- children: 1 3 5 6 10 (배열의 요소)

- 예제 출력
	- 3 (최소 비용)  

``` 

<br>
<br/>
    
## 풀이 및 설명

1 )    

`children` 배열의 요소들의 바로 앞 뒤 인접한 요소들과의 차이 값을 구하고 그 값을 새로운 배열에 할당한다.

문제에서 조건으로  `children`배열은 0번 Index의 계속 커지는 값이라고 명시했고 (정렬이 되어 있음)   
이때, 멀리 떨어져 있는 요소와 차이를 구하는거보다 바로 양 옆 Index의 요소들과의 차이를 구하는게   
차이값이 가장 작을 수 밖에 없다.

예를 들면 "A"라는 요소가 있다고 가정한다.
그러면,
$$children = [ ... A-2, A-1, "A", A+1, A+2... ]$$
이런식으로 볼 수 있을 것이다.

당연하게도 A와 계산되어 가장 작은 값을 낼 수 있는 요소들은 바로 양옆의 A-1와 A+1 이다.    
(둘다 A와 계산되어 "1"이라는 차이값을 내게 된다.)

위의 논리로 `children`배열에서 양옆요소들의 차이가 기준 요소(A)의 차이값을 가장 최소로 하는것임을 알수 있고   
우리는 요소들끼리의 차이를 계산하여 가장 최소의 값을 구하는 것이기 때문에   
`children`의 모든 요소들에 이 논리를 적용하여 차이값들을 gapList 배열에 할당해준다.   


2 )   
`children`배열의 요소들의 차이를 모두 구해서  `gapList` 할당 했으니 위 예제 입력에 대한 `gapList`값은   
$$gapList = [(3 - 1), (5 - 3), (6 - 5), (10 - 6)]$$
으로  [2, 2 ,1, 4]가 될 것이다.    
   
문제에서 입력으로 주어진 `children`은 [1, 3, 5, 6, 10] 이였다.   
여기서 요소마다 경계를 그룹으로 나눌때 사용할 경계를 둘 것인데   
그렇다면  [ 1 | 3 | 5 | 6 | 10 ] 으로 볼 수 있을것이다. (여기서 설명를 위해 "|"를 경계라고 표현한다)   

경계선 "|"의 갯수는 "4"개 즉, (n-1) 개의 경계선을 사용한것이고 4개의 경계선을 사용했다면
5개의 그룹이 나오게 된다.

그렇다면 예제 입력에서 주어진 그룹 k의 갯수는 3개이고 바로 위에서 알아봤듯이   
<span style="color:green">그룹이 3개일때 경계선은 2개 즉, (n-k) 가 필요하다는 것을 알 수 있다.</span>    

`gapList`는 `children`배열의 요소를 양옆 2개씩 그룹으로 묶어 차이값을 계산한 값들이고   
(2개씩 묶은 이유는 1번 참고)   
`gapList`의 각 요소들은  `children`에서의 요소를 2개씩 묶은 <span style="color:red">경계선</span>이라고 생각해보자   
[2, 2 ,1, 4]는 [(1, 3), (3, 5), (5, 6), (6, 10)] 으로 표현 할 수 있을 것이고    
(차이값 계산법은 조에서 가장 키가 큰 원생과 가장 키가 작은 원생의 키 차이이다.)   
<span style="color:green">그룹이 3개일때 경계선은 2개 즉, (n-k) 가 필요하기에</span>   

즉, 경계선은 (5-3) = 2개가 필요하다.   
따라서 [(1, 3), (3, 5), (5, 6), (6, 10)] 에서 차이값이 최소인 그룹 2개를 찾으면   
(1, 3) 혹은 (3, 5) (둘 중 무엇을 선택해도 상관없음) 와 (5, 6) 이고    
(1, 3), (5, 6)이라고 한다면 `gapList` 배열 [2, 2 ,1, 4] 에서 Index 0번과 2번에 해당하는 요소를 가르킨다. (2와 1)   

이 두 경계선 요소를 쉽게 찾기 위해 `gapList`을 정렬할 것이다.    
그럼 [1, 2, 2, 4]로 만들어지고 우리가 필요한 <span style="color:red">3개의 그룹으로</span>   
"K개의 조에 대해 티셔츠 만드는 비용의 최소값"을 만들어 주는   
경계선의 개수 2개 즉, n-k 개 이고    
정렬한 `gapList`는 가장 앞 요소부터 순서대로 가장 작은 차이값을 가질 것이고   

따라서, `gapList` 배열의 0번째 Index부터 ((n-k) - 1) Index까지 모두 더해주면 (gapList[0 ..< n-k])   
문제에서 구하려는  "K개의 조에 대해 티셔츠 만드는 비용의 최소값"을 구할 수 있게 된다.
